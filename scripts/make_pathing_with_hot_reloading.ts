import * as fsp from 'node:fs/promises';

const ACTIONS_FILE_PATH = './auto.json';

interface Var {
  name: string;
  type: string;
  data: any;
  is_serialized?: boolean;
  file_path?: string;
}

interface MethodCall {
  index: number;
  method_name: string;
  tag: string;
  args: Var[];
}

interface AutoBuilder {
  output_file_path: string;
  method_calls: MethodCall[];
}

(async () => {
  const builder: AutoBuilder = JSON.parse(await fsp.readFile(ACTIONS_FILE_PATH, 'utf8'));
  builder.method_calls.sort((a, b) => a.index - b.index);

  const package_name = builder.output_file_path
    .replace(/.*\\TeamCode\\src\\main\\/, '') // Remove everything before and including TeamCode/src/main/
    .replace(/(.*)\\.*$/, '$1')               // Drop the name of the java file and the preceding slash
    .replace(/\\/g, '.')                      // Replace slashes with dots
    .slice(5);                                // Drop the "java." at the beginning

  let output = '';
  let vars = '';

  output +=
    '// AUTOGENERATED FILE; DO NOT EDIT \n' +
    '\n' +
    `package ${package_name}; \n` +
    '\n' +
    'import androidx.annotation.NonNull; \n' +
    '\n' +
    'import com.acmerobotics.dashboard.config.Config; \n' +
    '\n' +
    'import org.firstinspires.ftc.teamcode.roadrunner.drive.SampleMecanumDrive; \n' +
    'import org.firstinspires.ftc.teamcodekt.components.scheduler.auto.AutoProvider; \n' +
    'import org.firstinspires.ftc.teamcodekt.components.scheduler.auto.ActualAutoBuilder; \n' +
    '\n' +
    'import java.io.IOException; \n' +
    'import java.io.ObjectInput; \n' +
    'import java.io.FileInputStream; \n' +
    'import java.io.ObjectInputStream; \n' +
    '\n' +
    '@Config \n' +
    'public class AutoProviderImpl implements AutoProvider { \n' +
    '    @Override \n' +
    '    public void scheduleAuto(@NonNull SampleMecanumDrive drive) { \n' +
    '        ActualAutoBuilder builder = new ActualAutoBuilder(drive) \n';

  for (const method of builder.method_calls) {
    method.args.filter(arg => !arg.is_serialized).forEach(arg => {
      const var_name = `${method.tag}$${arg.name}`;

      vars +=
        `    public static ${arg.type} ${var_name} = ${arg.data};\n\n`;
    });

    method.args.filter(arg => arg.is_serialized).forEach(arg => {
      const var_name = `${method.tag}$${arg.name}`;

      const file_path = arg.file_path?.replace(/\\/g, '\\\\');

      vars +=
        `    public static ${arg.type} ${var_name}; \n` +
        '    static { \n' +
        `        try (ObjectInput oi = new ObjectInputStream(new FileInputStream("${file_path}"))) { \n` +
        `            ${var_name} = (${arg.type}) oi.readObject(); \n` +
        '        } catch (IOException | ClassNotFoundException e) { \n' +
        '            e.printStackTrace(); \n' +
        '        } \n' +
        '    } \n' +
        '\n';
    });

    const method_args = method.args.map(arg => `${method.tag}$${arg.name}`).join(', ');

    output +=
      `            .${method.method_name}(${method_args}) \n`;
  }

  output = output.slice(0, -2) + '; \n';

  output +=
    '    } \n' +
    '\n' +
    vars;

  output = output.slice(0, -1) + '} \n';

  console.log(output);

  await fsp.writeFile(builder.output_file_path, output);
})();
