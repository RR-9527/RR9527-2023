// noinspection GrazieInspection

import * as fsp from 'node:fs/promises';
import { Argument, AutoBuilder, AutoBuilderConfig, MethodCall } from './types';

// const CONFIG_FILE_PATH = './.tunableautoconfig';
const CONFIG_FILE_PATH = 'C:\\Users\\wanna\\Documents\\GitHub\\RR9527-2023\\.tunableautoconfig';

/**
 * Reads in a JSON file of auto builder method calls and some given metadata, and turns it
 * into a new Java class, mapping all the variables (except for ones that have to be deserialized)
 * into `public static <type>` fields, to allow for quick tuning of the values from the Roadrunner dashboard.
 *
 * It won't fully hot reload, but you will be able to simply restart the auto to see the changes, as opposed
 * to having to recompile and repush the entire project.
 *
 * ~~in hindsight, why would you even fully hot reload in an auto lol~~
 */
(async () => {
  const config_json = await fsp.readFile(CONFIG_FILE_PATH, 'utf-8');
  const config: AutoBuilderConfig = JSON.parse(config_json);

  const builder_json = await fsp.readFile(config.json_output_path, 'utf8');
  const builder: AutoBuilder = JSON.parse(builder_json);

  // It should already be sorted, but just in case
  builder.method_calls.sort(byOrderOfDeclaration);

  // Extracts the package name from the output file path
  // e.g.
  // '...\TeamCode\src\main\java\org\firstinspires\ftc\teamcode\opmodes\auto\???.java'
  // ->
  // 'org.firstinspires.ftc.teamcode.opmodes.auto'
  const package_name = config.java_output_path
    .replace(/\//g, '\\')                   // Normalizes file path separators
    .replace(/.*TeamCode\\src\\main\\/, '') // Remove everything before and including TeamCode/src/main/
    .replace(/(.*)\\.*$/, '$1')             // Drop the name of the java file and the preceding slash
    .replace(/\\/g, '.')                    // Replace slashes with dots
    .slice(5);                              // Drop the "java." at the beginning

  let file = '';
  let vars = '';

  file +=
    '// AUTOGENERATED FILE; DO NOT EDIT                                                      \n' +
    '                                                                                        \n' +
    `package ${package_name};                                                                \n` +
    '                                                                                        \n' +
    'import androidx.annotation.NonNull;                                                     \n' +
    '                                                                                        \n' +
    'import com.acmerobotics.dashboard.config.Config;                                        \n' +
    '                                                                                        \n' +
    'import org.firstinspires.ftc.teamcode.roadrunner.drive.SampleMecanumDrive;              \n' +
    'import org.firstinspires.ftc.teamcode.roadrunner.trajectorysequence.TrajectorySequence; \n' +
    'import org.firstinspires.ftc.teamcodekt.components.scheduler.auto.AutoProvider;         \n' +
    'import org.firstinspires.ftc.teamcodekt.components.scheduler.auto.ActualAutoBuilder;    \n' +
    '                                                                                        \n' +
    'import java.io.IOException;                                                             \n' +
    'import java.io.ObjectInput;                                                             \n' +
    'import java.io.FileInputStream;                                                         \n' +
    'import java.io.ObjectInputStream;                                                       \n' +
    '                                                                                        \n' +
    '@Config                                                                                 \n' +
    'public class AutoProviderImpl implements AutoProvider {                                 \n' +
    '    @Override                                                                           \n' +
    '    public TrajectorySequence createAuto(@NonNull SampleMecanumDrive drive) {           \n' +
    '        ActualAutoBuilder builder = new ActualAutoBuilder(drive)                        \n';


  // Iterates through all of the method calls to map each and every ones' arguments into
  // public static <type> fields (unless, of course, the argument is serialized)
  builder.method_calls.forEach(method => {

    let method_call = `            .${method.method_name}(`;

    method.args.forEach(arg => {
      const var_name = varName(method, arg);

      switch (true) {
        // The tunable arguments of the method calls can just be declared in a straightforward manner, as
        // `public static <type> <var_name> = <arg.data>;`
        // and passed into each method call through the variable name.
        case arg.is_tunable:
          vars +=
            `    public static ${arg.type} ${var_name} = ${arg.data};\n\n`;

          method_call += `${var_name}, `;
          break;

        // The serialized arguments of the method calls, however, (i.e. lambdas) need to be deserialized
        // from some file, likely some random temp file.
        // There is no reason to declare it 'public static' because there's no way you can edit
        // a lambda in the dashboard anyway.
        // It would just pollute the variable list.
        case arg.is_serialized:
          const file_path = arg.file_path?.replace(/\\/g, '\\\\');

          vars +=
            `    private static ${arg.type} ${var_name};                                                   \n` +
            '    static {                                                                                  \n' +
            `        try (ObjectInput oi = new ObjectInputStream(new FileInputStream("${file_path}"))) {   \n` +
            `            ${var_name} = (${arg.type}) oi.readObject();                                      \n` +
            '        } catch (IOException | ClassNotFoundException e) {                                    \n' +
            '            e.printStackTrace();                                                              \n' +
            '        }                                                                                     \n' +
            '    }                                                                                         \n' +
            '                                                                                              \n';

          method_call += `${var_name}, `;
          break;

        // The non-tunable, non-serialized arguments of the method calls are just passed in as-is.
        default:
          method_call += `${arg.data}, `;
      }
    });

    // The `slice` is to remove the trailing comma and space
    file += method_call.slice(0, -2) + ')\n';
  });

  // Goes back up a line and adds a finishing semicolon
  file = file.slice(0, -1) + '; \n';

  // Closes the main method, and declares the variables
  file +=
    '                                                                                           \n' +
    '        return builder.build();                                                            \n' +
    '    }                                                                                      \n' +
    '                                                                                           \n' +
    `    ${vars}                                                                                \n`;

  // Removes all the unnecessary whitespace at the end of each line
  file = file.replace(/ *\r?\n/g, '\n');

  // Deletes the trailing newlines and closes the class
  file = file.slice(0, -2) + '} \n';

  console.log(file);

  console.log(config);

  await fsp.writeFile(config.java_output_path, file);

  await fsp.unlink(config.json_output_path);
})();

/**
 * Generates a variable name for the given method call and argument.
 *
 * _Unless the tag was overridden, the variable name end up following this pattern:_
 * ```
 * <method_name><num_times_called>$<arg_name>
 * // e.g. "drive3$distance"
 * ```
 *
 * _If the tag was overridden, the variable name will be like:_
 * ```
 * <tag>$<arg_name>
 * // e.g. "initial_spline_2_tall_pole$x"
 * ```
 * @param method The method that the argument belongs to
 * @param arg The argument in question
 */
function varName(method: MethodCall, arg: Argument) {
  return `${method.tag}$${arg.name}`;
}

/**
 * Sorts the method calls by the order they were called in the `TuningAutoBuilder`.
 */
function byOrderOfDeclaration(a: MethodCall, b: MethodCall) {
  return a.index - b.index;
}
