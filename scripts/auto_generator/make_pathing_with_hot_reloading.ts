// noinspection GrazieInspection

import * as fsp from 'node:fs/promises';
import { Argument, AutoBuilder, AutoBuilderConfig, MethodCall } from './types';

const CONFIG_FILE_PATH = './.tunableautoconfig';

/**
 * Reads in a JSON file of auto builder method calls and some given metadata, and turns it
 * into a new Java class, mapping all the variables (except for ones that have to be deserialized)
 * into `public static <type>` fields, to allow for quick tuning of the values from the Roadrunner dashboard.
 *
 * It won't fully hot reload, but you will be able to simply restart the auto to see the changes, as opposed
 * to having to recompile and repush the entire project.
 *
 * ~~in hindsight, why would you even fully hot reload in an auto lol~~
 */
(async () => {
  const config_json = await fsp.readFile(CONFIG_FILE_PATH, 'utf-8');
  const config: AutoBuilderConfig = JSON.parse(config_json);

  const builder_json = await fsp.readFile(config.json_output_path, 'utf8');
  const builder: AutoBuilder = JSON.parse(builder_json);

  // It should already be sorted, but just in case
  builder.method_calls.sort(byOrderOfDeclaration);

  // Extracts the package name from the output file path
  // e.g.
  // '...\TeamCode\src\main\java\org\firstinspires\ftc\teamcode\opmodes\auto\???.java'
  // ->
  // 'org.firstinspires.ftc.teamcode.opmodes.auto'
  const package_name = config.java_output_path
    .replace(/\//g, '\\')                   // Normalizes file path separators
    .replace(/.*TeamCode\\src\\main\\/, '') // Remove everything before and including TeamCode/src/main/
    .replace(/(.*)\\.*$/, '$1')             // Drop the name of the java file and the preceding slash
    .replace(/\\/g, '.')                    // Replace slashes with dots
    .slice(5);                              // Drop the "java." at the beginning

  let file = '';
  let vars = '';

  file +=
`// AUTOGENERATED FILE; DO NOT EDIT

package ${package_name}; \n
import androidx.annotation.NonNull;

import com.acmerobotics.dashboard.config.Config;

import org.firstinspires.ftc.teamcode.roadrunner.drive.SampleMecanumDrive;
import org.firstinspires.ftc.teamcodekt.components.scheduler.auto.AutoProvider;
import org.firstinspires.ftc.teamcodekt.components.scheduler.auto.ActualAutoBuilder;

import java.io.IOException;
import java.io.ObjectInput;
import java.io.FileInputStream;
import java.io.ObjectInputStream;

@Config
public class AutoProviderImpl implements AutoProvider {
    @Override
    public void scheduleAuto(@NonNull SampleMecanumDrive drive) {
        ActualAutoBuilder builder = new ActualAutoBuilder(drive)
`;

  // Iterates through all of the method calls to map each and every ones' arguments into
  // public static <type> fields (unless, of course, the argument is serialized)
  for (const method of builder.method_calls) {
    // The unserialized arguments of the method calls (i.e. pretty much likely everything except lambdas)
    // can just be declared in a straightforward manner
    method.args.filter(arg => !arg.is_serialized).forEach(arg => {
      const var_name = varName(method, arg);

      vars +=
        `    public static ${arg.type} ${var_name} = ${arg.data};\n\n`;
    });

    // The serialized arguments of the method calls, however, (i.e. lambdas) need to be deserialized
    // from some file, likely some random temp file.
    // There is no reason to declare it 'public static' because there's no way you can edit
    // a lambda in the dashboard anyway.
    // It would just pollute the variable list.
    method.args.filter(arg => arg.is_serialized).forEach(arg => {
      const var_name = varName(method, arg);

      const file_path = arg.file_path?.replace(/\\/g, '\\\\');

      vars +=
        `    private static ${arg.type} ${var_name}; \n` +
        '    static { \n' +
        `        try (ObjectInput oi = new ObjectInputStream(new FileInputStream("${file_path}"))) { \n` +
        `            ${var_name} = (${arg.type}) oi.readObject(); \n` +
        '        } catch (IOException | ClassNotFoundException e) { \n' +
        '            e.printStackTrace(); \n' +
        '        } \n' +
        '    } \n' +
        '\n';
    });

    // Finally, we can add each method call to the main `scheduleAuto` method
    // The arguments are passed in the order they were declared in the JSON file
    const method_args = method.args.map(arg => varName(method, arg)).join(', ');

    file +=
      `            .${method.method_name}(${method_args}) \n`;

    // ^^^ notice the indentation
  }

  // Goes back up a line and adds a finishing semicolon
  file = file.slice(0, -2) + '; \n';


  // Closes the `scheduleAuto` method and declares all the variables
  file +=
    '    } \n' +
    '\n' +
    vars;

  // Deletes the trailing newline and closes the class
  file = file.slice(0, -1) + '} \n';

  console.log(file);

  await fsp.writeFile(config.java_output_path, file);
})();

/**
 * Generates a variable name for the given method call and argument.
 *
 * _Unless the tag was overridden, the variable name end up following this pattern:_
 * ```
 * <method_name><num_times_called>$<arg_name>
 * // e.g. "drive3$distance"
 * ```
 *
 * _If the tag was overridden, the variable name will be like:_
 * ```
 * <tag>$<arg_name>
 * // e.g. "initial_spline_2_tall_pole$x"
 * ```
 * @param method The method that the argument belongs to
 * @param arg The argument in question
 */
function varName(method: MethodCall, arg: Argument) {
  return `${method.tag}$${arg.name}`;
}

/**
  * Sorts the method calls by the order they were called in the `TuningAutoBuilder`.
 */
function byOrderOfDeclaration(a: MethodCall, b: MethodCall) {
  return a.index - b.index;
}
